// ConsoleApplication2.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <string>
#include <cstring>
#include <conio.h>
#include <stdlib.h>
#include <Windows.h>
#define ROWS 25
#define COLUMNS 25

/*useful characters to have:

interpunct: '·' - this is for normal ground
overline: ‾: 
*/

/*
								                                 
 __     __
|  |--.|__|.-----.-----.--.--.-----.
|  _  ||  ||     |  _  |  |  |__ --|
|_____||__||__|__|___  |_____|_____|
				 |_____|


*/

HANDLE theHandl = nullptr;

void gotoxy(int x, int y)
{
	if (theHandl == nullptr)
	{
		theHandl = GetStdHandle(STD_OUTPUT_HANDLE);
	}

	COORD cord;
	cord.X = x;
	cord.Y = y;
	SetConsoleCursorPosition(theHandl, cord);
}


class Player
{
public:
	Player() {};
	~Player() {};
	char playerChar = '@';
	int x = 0;
	int y = 0;
	int prev_x = 0;
	int prev_y = 0;
	int health = 4;
private:
};


class NonPlayerCharacter
{
	NonPlayerCharacter() {};
	~NonPlayerCharacter() {};
	char npcChar = 'Ω';
	int x = 0;
	int y = 0;
	int prev_x = 0;
	int prev_y = 0;
	int health = 3;
private:

};

class WorldMap
{
public:
	WorldMap() {};
	~WorldMap() {};

	void printMap()
	{
		for(int n = 0; n < ROWS; n++) {
			for (int m = 0; m < COLUMNS ; m++) {
				std::cout << tilesActive[n][m];
			}
			std::cout << std::endl;
		}
	}

	void setTile(char character, int row, int column, int prev_row, int prev_column)
	{
		tilesActive[prev_row][prev_column] = tilesBase[prev_row][prev_column];
		tilesActive[row][column] = character;
	}

	int checkWallCollision(int dest_x, int dest_y) {
		if (tilesBase[dest_y][dest_x] != '.') {
			return 0;
		}
		else
		{
			return 1;
		}
	}

private:

	const int rows = ROWS;
	const int columns = COLUMNS;

	char tilesActive[ROWS][COLUMNS] = {
	{'.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','#','#','#','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','#','#','#','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'}
	};

	char tilesBase[ROWS][COLUMNS] = {
	{'.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','#','#','#','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','.','.','.','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','#','#','#','#','#','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'},
	{'.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'}
	};
};


int main()
{
	Player hrac;
	WorldMap mapa;

	while (true)
	{

		mapa.printMap();

		char input = _getch();

		system("CLS");

		switch (input) {
		case '8':
			//collision for walls
			if (mapa.checkWallCollision(hrac.x, hrac.y-1) == 0) { break; }
			//out of bounds for up
			if (hrac.y > 0) {
				hrac.prev_x = hrac.x;
				hrac.prev_y = hrac.y;
				hrac.y--;
			}
			break;
		case '9':
			if (mapa.checkWallCollision(hrac.x+1, hrac.y-1) == 0) { break; }
			//out of bounds for up
			if ((hrac.x + 1 < COLUMNS) && (hrac.y > 0)) {
				hrac.prev_x = hrac.x;
				hrac.prev_y = hrac.y;
				hrac.x++;
				hrac.y--;
			}
			break;
		case '6':
			if (mapa.checkWallCollision(hrac.x+1, hrac.y) == 0) { break; }
			//out of bounds for right
			if (hrac.x + 1 < COLUMNS) {
				hrac.prev_x = hrac.x;
				hrac.prev_y = hrac.y;
				hrac.x++;
			}
			break;
		case '3':
			if (mapa.checkWallCollision(hrac.x+1, hrac.y+1) == 0) { break; }
			//out of bounds for up
			if ((hrac.x + 1 < COLUMNS) && (hrac.y + 1 < ROWS)) {
				hrac.prev_x = hrac.x;
				hrac.prev_y = hrac.y;
				hrac.x++;
				hrac.y++;
			}
			break;
		case '4':
			if (mapa.checkWallCollision(hrac.x-1, hrac.y) == 0) { break; }
			//out of bounds for left
			if (hrac.x > 0) {
				hrac.prev_x = hrac.x;
				hrac.prev_y = hrac.y;
				hrac.x--;
			}
			break;
		case '2':
			if (mapa.checkWallCollision(hrac.x, hrac.y+1) == 0) { break; }
			//out of bounds for down
			if (hrac.y + 1 < ROWS) {
				hrac.prev_x = hrac.x;
				hrac.prev_y = hrac.y;
				hrac.y++;
			}
			break;
		case '1':
			if (mapa.checkWallCollision(hrac.x-1, hrac.y+1) == 0) { break; }
			if ((hrac.x > 0) && (hrac.y + 1 < ROWS)) {
				hrac.prev_x = hrac.x;
				hrac.prev_y = hrac.y;
				hrac.x--;
				hrac.y++;
			}
			break;
		case '7':
			if (mapa.checkWallCollision(hrac.x-1, hrac.y-1) == 0) { break; }
			if ((hrac.x > 0) && (hrac.y > 0)) {
				hrac.prev_x = hrac.x;
				hrac.prev_y = hrac.y;
				hrac.x--;
				hrac.y--;
			}
			break;
		}

		mapa.setTile(hrac.playerChar, hrac.y, hrac.x, hrac.prev_y, hrac.prev_x);

		std::cout << "CURRENT: " << hrac.x << "," << hrac.y << std::endl;
		//std::cout << "PREV: " <<  hrac.prev_x << "," << hrac.prev_y << std::endl;
	}


	//zjistit proc ty previous veci nefungujou bez davani prev_x  = x i kdyz se hybeme jen na y
	return 0;

}